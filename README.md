# 6W6L
This is a project under <ins>**[Programming Club, IIT Kanpur](https://pclub.in/)**</ins>
### **Mentors** 
- [Atharv Singh Patlan](https://github.com/AthaSSiN)
- [Kartikeya Gupta](https://github.com/kartikcode)
- [Som Tambe](https://github.com/SomTambe)
### **AIM:**
The main aim of this project is to get familiar with six different languages (Python, Ruby, JavaScript, Golang, Julia & Scala) and to understand the different paradigms of programming.

*****************************
# **General Concepts**
## **Classification**
Programming Languages can be classified on the basis of:
### 1) Programming Paradigms
Programming Paradigm define technique of writing a program and how it works. It is mainly classified into following two types:-
- **Imperative**:- Imperative programming is typically interacting directly with the state of the computer, and deciding how things are to be calculated. </br>
- **Declarative**:- Declarative programming is when the programmer behind the wheel isn’t effectively programming exactly what a computer does at any given moment — but instead describes properties of the result they want while not explaining how to compute it.</br></br>
For more info visit: <ins>[https://www.geeksforgeeks.org/introduction-of-programming-paradigms/](https://www.geeksforgeeks.org/introduction-of-programming-paradigms/)</ins>
### 2) Programming Models
Programming models are a way to classify programming languages based on their features.Languages can be classified into many, many models. Some common programming models are:-
- **Procedural Oriented**: In such languages, the program code is written as a sequence of instructions mainly in the form of sub-functions. This has been derived from structured programming.Examples include <ins>C</ins> and <ins>FORTRAN</ins>.</br>
- **Purely Object Oriented**: In such languages, everything is compiled as an object. Cosequently, such languages become extensible too as one can define his own fucntions specific to even any constant( like a number)!. <ins>Ruby</ins> is one such language.</br>
- **Purely Functional**: In languages like <ins>Haskell</ins>, everything is considered to be a function. Here, functions also do not have any side-effects ,i.e., no function can alter the internal state of some variable.</br>
- **Logic Programming**: For these, <ins>PROLOG</ins>(programming in logic) is the best known example. Here, a program is executed by an “inference engine” that answers a query by searching these relations systematically to make inferences that will answer a query.
### 3) Type System
A type system is a mechanism for defining, detecting, and preventing illegal program states. It works by defining and applying constraints. The constraint definitions are types, and, the constraint applications are usages of types, e.g. in variable declaration. Various Type Systems are:-
- **Strong vs Weak typing**: The distinction is not strict. If typing rules are enforced more strictly, the typing is said to be strong and weak if otherwise. The terms are relative.</br>
E.g. Java is considered strong while Javascript is considered weak.</br>
- **Static vs Dynamic typing**: In static typing, the type is determined at compile time/time of writing the code. In dynamic typing, type safety is verified at runtime.</br>
Examples of statically typed languages are C, C++, Haskell, etc while dynamically typed languages are Python and Ruby.</br>
- **Manifest vs Inferred**: In manifest typing, type has to be explicitly declared. While in inferred typing, the type is intelligently detected.</br>
Example of Manifest typing is C whereas Inferred typing is Python.</br>
- **Nominal vs Structural**: Nominal typing means that two variables are type-compatible if and only if their declarations name the same type. For example, in C, two struct types with different names in the same translation unit are never considered compatible, even if they have identical field declarations. In structural type system, equivalence is determined only by the type's actual structure.</br>
Examples of languages following Nominal typing is C whereas languages following Structural typing are OCaml and Go.</br>
- **Duck Typing**: It is similar to, but different from structural typing. An object's suitability is determined by the presence of certain methods and properties, rather than the type of the object itself. That is, if we have different types which have the same method, we can write code agnostically.</br></br>
For more info visit the following article: <ins>[https://thevaluable.dev/type-system-explained/](https://thevaluable.dev/type-system-explained/)</ins>